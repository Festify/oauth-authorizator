<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">
<link rel="import" href="url-polyfill.html">

<dom-module id="oauth-authorizator">
    <template>
        <iron-ajax id="exchangeAjax"
                   content-type="application/x-www-form-urlencoded"
                   handle-as="json"
                   headers="[[headers]]"
                   method="post"
                   url="[[tokenExchangeUrl]]">
        </iron-ajax>
        <iron-ajax id="refreshAjax"
                   content-type="application/x-www-form-urlencoded"
                   handle-as="json"
                   headers="[[headers]]"
                   method="post"
                   url="[[tokenRefreshUrl]]">
        </iron-ajax>
    </template>
</dom-module>

<script>
    /**
     * `oauth-authorizator`
     *
     * A Polymer 2.0 Element that performs the OAuth2 authorization code flow.
     *
     * @customElement
     * @polymer
     */
    class OauthAuthorizator extends Polymer.Element {
        static get errors() {
            return {
                AUTH_WINDOW_CLOSED: 'auth_window_closed',
                HTTP_ERROR: 'http',
                INVALID_PARAMETER: 'parameter',
                OAUTH_ERROR: 'oauth_error',
                STATE_MISMATCH: 'state_mismatch',
                UNKOWN: 'unknown'
            };
        }

        static get is() {
            return 'oauth-authorizator';
        }

        static get properties() {
            return {
                /**
                 * A valid access token.
                 *
                 * This will automatically be refreshed before it times out.
                 *
                 * @type String
                 */
                accessToken: {
                    type: String,
                    notify: true,
                },

                /**
                 * The authorization endpoint.
                 *
                 * E.g. https://accounts.spotify.com/authorize
                 *
                 * @type String
                 */
                authorizationUrl: {
                    type: String
                },

                /**
                 * The client ID.
                 *
                 * @type String
                 */
                clientId: {
                    type: String
                },

                /**
                 * Custom headers to send to the token services.
                 *
                 * Setting a `Content-Type` header here will override how the request
                 * body is encoded during the request to the token exchange service.
                 *
                 * @type Object
                 */
                headers: {
                    type: Object
                },

                /**
                 * Indicates whether the authentication process currently is in process.
                 *
                 * @type Boolean
                 */
                inProgress: {
                    type: Boolean,
                    notify: true
                },
                
                /**
                 * The key of the local storage item to save the refresh token to.
                 * 
                 * Defaults to `oauth-authorizator:refreshToken`.
                 * 
                 * @type String
                 */ 
                localStorageKey: {
                    type: String,
                    value: () => 'oauth-authorizator:refreshToken'
                },

                /**
                 * The URI to redirect to when the authorization has completed.
                 *
                 * @type String
                 */
                redirectUrl: {
                    type: String
                },

                /**
                 * The authorization scopes to request.
                 *
                 * @type String[]
                 */
                scopes: {
                    type: Array
                },

                /**
                 * The URI to exchange the authorization code into a full access token through.
                 *
                 * @type String
                 */
                tokenExchangeUrl: {
                    type: String
                },

                /**
                 * The URL to refresh an expired access token through.
                 *
                 * If this is null when `login` is called, the obtained
                 * access token will not automatically be refreshed.
                 *
                 * @type String
                 */
                tokenRefreshUrl: {
                    type: String
                },

                /**
                 * The interval descriptor for the token refresh task.
                 *
                 * @type Number
                 */
                _refreshInterval: {
                    type: Number
                }
            };
        }

        /**
         * Forgets the currently logged-in user and stops the automatic access
         * token refresh process.
         */
        forget() {
            localStorage.removeItem(this.localStorageKey);
            clearInterval(this._refreshInterval);

            this.setProperties({
                accessToken: null,
                _refreshInterval: null
            });
        }

        /**
         * Performs the OAuth authorization process.
         *
         * First, this attempts to relogin the current user. If that doesn't
         * work, this method triggers the full OAuth authorization. When that is
         * done, it starts the automatic access token refresh process.
         */
        login() {
            if (!this.authorizationUrl) {
                throw new Error(
                    "Authentication URL is null or empty!",
                    OauthAuthorizator.errors.INVALID_PARAMETER
                );
            }
            if (!this.redirectUrl) {
                throw new Error(
                    "Redirect URL is null or empty!",
                    OauthAuthorizator.errors.INVALID_PARAMETER
                );
            }
            if (!this.tokenRefreshUrl) {
                throw new Error(
                    "Token refresh URL is null or empty!",
                    OauthAuthorizator.errors.INVALID_PARAMETER
                );
            }
            if (!this.tokenExchangeUrl) {
                throw new Error(
                    "Token exchange URL is null or empty!",
                    OauthAuthorizator.errors.INVALID_PARAMETER
                );
            }

            this.inProgress = true;
            return this._refresh()
                .then(resp => resp ? resp : this._authenticate())
                .then(res => {
                    this.inProgress = false;
                    return res;
                });
        }

        _authenticate() {
            // Generate random ASCII string
            const state = (Math.random().toString(36) + '00000000000000000').slice(2, 9);

            return new Promise((res, rej) => {
                const authUrl = new URL(this.authorizationUrl);
                authUrl.searchParams.set('client_id', this.clientId);
                authUrl.searchParams.set('redirect_uri', this.redirectUrl);
                authUrl.searchParams.set('response_type', 'code');
                authUrl.searchParams.set('scope', (this.scopes || []).join(' '));
                authUrl.searchParams.set('state', state);

                const w = window.open(authUrl.toString());
                if (!w) {
                    return rej(new Error(
                        "Window handle was null.",
                        OauthAuthorizator.errors.UNKNOWN
                    ));
                }

                const redirUrl = new URL(this.redirectUrl);
                const i = setInterval(() => {
                    if (w.closed) {
                        clearInterval(i);
                        return rej(new Error(
                            "Authorization window has been closed.",
                            OauthAuthorizator.errors.AUTH_WINDOW_CLOSED
                        ));
                    }

                    if (!w.location) {
                        clearInterval(i);
                        return rej(new Error(
                            "Window location was null.",
                            OauthAuthorizator.errors.UNKNOWN
                        ));
                    }

                    const loc = new URL(w.location);
                    if (loc.protocol !== redirUrl.protocol ||
                        loc.host !== redirUrl.host ||
                        loc.pathname !== redirUrl.pathname) {
                        return;
                    }

                    clearInterval(i);
                    w.close();
                    const code = loc.searchParams.get('code');
                    const error = loc.searchParams.get('error');
                    const s = loc.searchParams.get('state');

                    if (s !== state) {
                        return rej(new Error(
                            "State value didn't match.",
                            OauthAuthorizator.errors.STATE_MISMATCH
                        ));
                    }
                    if (error) {
                        return rej(new Error(
                            error,
                            OauthAuthorizator.errors.OAUTH_ERROR
                        ));
                    }

                    res(code);
                }, 100);
            })
                .then(code => {
                    this.$.exchangeAjax.body = { code: encodeURIComponent(code) };
                    return this.$.exchangeAjax.generateRequest().completes
                        .catch(err => Promise.reject(new Error(err, OauthAuthorizator.errors.HTTP_ERROR)));
                })
                .then(({ response }) => {
                    if (response.refresh_token && response.expires_in) {
                        localStorage.setItem(this.localStorageKey, response.refresh_token);

                        clearInterval(this._refreshInterval);
                        this._refreshInterval = setInterval(
                            () => this._refresh(),
                            response.expires_in * 950
                        );
                    }

                    this.accessToken = response.access_token;
                    return response;
                });
        }

        _refresh() {
            const rt = localStorage.getItem(this.localStorageKey);
            if (!rt) {
                clearInterval(this._refreshInterval);
                return Promise.resolve();
            }

            return this._retry(() => {
                this.$.refreshAjax.body = { refresh_token: rt };
                return this.$.refreshAjax.generateRequest().completes
                    .then(({ response }) => {
                        if (response.expires_in) {
                            clearInterval(this._refreshInterval);
                            this._refreshInterval = setInterval(
                                () => this._refresh(),
                                response.expires_in * 950
                            );
                        }

                        this.accessToken = response.access_token;
                        return response;
                    });
            }, 5000, 10);
        }

        _retry(fn, delay, max) {
            return new Promise((res, rej) => {
                const attempt = () => {
                    fn()
                        .then(res)
                        .catch(err => {
                            if (max-- > 0) {
                                setTimeout(attempt, delay);
                            } else {
                                rej(err);
                            }
                        });
                };

                attempt();
            });
        }
    }

    window.customElements.define(OauthAuthorizator.is, OauthAuthorizator);
</script>